<!DOCTYPE html>
<html>
<head>
<title>Typeclasses</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel='stylesheet' type='text/css' href='style.css' />
</head>
<body>
<textarea id="source">

class: center, middle, transition, intro

#  Typeclasses

.caption[Daniel Beskin]
???
- In this talk we are going to discuss typeclasses
- Typeclasses are a functional "design pattern"
- It allows us to write extendible code at the right level of abstraction
- This pattern is very common in the Scala ecosystem
- Learning it will make various libraries easier to use

---
class: center, middle, transition

Motivation - Sorting

???
- First, a bit of motivation to get ourselves started
- The running example will be a generic sorting function
---
## Java-style, take #1 - Inheritance
```
trait Orderable[A] {
  def compare(that: A): Int
}


{{content}}
```

???
- Here's a naive Java style attempt
- We define a `Orderable` trait for things that can be sorted by our function

--
def sort[A <: Orderable](xs: List[A]): List[A]


{{content}}
???
- Given a list of `Orderable`s, we can use their `compare` method to sort them
- For example:
--

case class Clippy(annoyanceLevel: Int) extends Orderable[Clippy] {
  def compare(that: Clippy) = ???
}

???
- The problem with that approach is that it's not extensible
- If a type is not in our control, we can't make it `Orderable` after the fact
---

## Java-style, take #2 - Adapter

```
trait Oredring[A] {
  def compare(x: A, y: A): Int
}


{{content}}
```

???
- Taking out our design patterns book, the Adapter design pattern fits the bill
- It allows to adapt existing classes to our new abtraction
- We now define `Ordering` as a standalone entity

--
def sort[A](xs: List[A], ord: Ordering[A]): List[A]


{{content}}
???
- Sorting now takes an adapter parameter
- And so we can now adapt any existing class to our `Ordering` abstraction

--

case class Clippy(annoyanceLevel: String)


val clippyOrdering = new Ordering[Clippy] {
  def compare(x: Clippy, y: Clippy) = ???
}


sort(List(c1, c2, c3), clippyOrdering)

???
- We now have an extensible ordering, but the usage is a bit clumsy, we have
to pass these `Ordering` around
- Given that we use Scala, we can sprinkle some implicit magic to make it a bit
nicer to use

---
## Java-semi-Scala-style

```
def sort[A](xs: List[A])(implicit ord: Ordering[A]): List[A]


{{content}}
```

--
implicit val clippyOrdering = new Ordering[Clippy] {
  def compare(x: Clippy, y: Clippy) = ???
}


sort(List(c1, c2, c3))

???
- Now we don't have to pass `Ordering`s around
- Once we make them implicit, the compiler will take care of passing them around for us
- And that's about 90% of typeclasses
- The typeclasses formalizes this pattern, and gives a bit more of a punch

---
class: center, middle, transition

Definition
???
- Now we are ready to actually define typeclasses

---
## Typeclasses - Definition


A class:
```
trait Oredring[A] {
  def compare(x: A, y: A): Int
}
```
???
- A typeclasses consists of a "class definition"
- Typically a trait, parameterized by a type variable, `A`
- With methods operating on `A`
- The terminonlogy comes from Haskell, where type classes are an actual specially supported language feature
- The word "class" here has nothing to do with OO-style classes
--

An instance:

```
implicit val clippyOrdering = new Ordering[Clippy] {
  def compare(x: Clippy, y: Clippy) = ???
}
```

???
- For a given class definition we can have many "instances"
- An instance is defined for a specific choice of the type parameter `A`
- An instance is provided as an implicit value or definition
- This is called "the Ordering instance for `Clippy`"
- What we are doing is declaring the fact that the type can be ordered, and tell the compiler how
- In other words: the `Clippy` type belongs to a class of types that have an `Oredring`
- Hence the name of the pattern: "typeclasses"

---
## Typeclasses at the Use-site

Generic functions:

```
def sort[A](xs: List[A])(implicit ord: Ordering[A]): List[A]


{{content}}
```
???
- We use typeclasses to define functions that are generic over the typeclass instance
- This can be rewritten as follows
--
def sort[A: Ordering](xs: List[A]): List[A]

???
- This is equivalent to the above line but better conveys our intent
- Which is: given that `A` has an instance of `Ordering`, that is it belong to the `Ordering` class, then we can define a sort for it
- The syntax is called a "context bound", meaning that we operate on `A`, given some context can be implicitly provided for `A`
--

Operator syntax
```
implicit class OrderingOps[A: Ordering](a: A) {
  def <=(other: A) = ???
}


Clippy(2) <= Clippy(5)
```

???
- Since typeclasses are defined outside the object that actually use them
- It's often use the pimp my type pattern to define operator syntax for instances of some classes
- This reads as follows: given that `A` has an instance of `Ordering`, we can use the following methods/operators on it
- Where inside the definitions will make some use of of the implicit typeclass instance that we have in scope

---

## Benefits
--

- Abstraction

???
- Code that we write against a typeclass instance can be very generic
- Since it works directly with an abstraction, it is precise, we don't have access to any information outside the abstraction
- This can lead to much code reuse, since a single definition can be applicable in many contexts
--

- Extensibility

???
- Unlike the inheritance based OO solution, typeclasses are extensible
- A type can be included in a class even after the type was defined
- This means that we can adapt old code to new use cases without modifying the code itself
--

- Type-driven
???
- The two previous items were also applicable to the `Adapter` pattern
- What we gain in make use of implicits, is the fact that the compiler can do some work for us
- We can think of implicits as a way to tell the compiler some information
- By creating an implicit `Ordering` for `Clippy`, we are telling the compiler that `Clippy` can be ordered
- The compiler can use this information to derive new facts from it, like how to make an `Ordering` for `List[Clippy]`
- For example
--

        implicit def listOrd[A: Ordering]: Ordering[List[A]]

---
## Un-benefits

- Indirection

???

- Writing typeclasses-heavy code can lead to significant amount of indirection
- Which in some cases may not be appropriate and result in harder to code to read/maintain
- This may, also, sometimes have performance consequences (though we'll see  how to address it later on)

--

- No direct language support

???

- Typeclasses, as a whole, are not a language feature, correspondingly, there isn't direct language support for it
- For example: there isn't special Scaladoc format for it, and the compilation errors may not be as informative as possible
--

- Implicit madness

???

- Last, since typeclasses make use of implicits, in some cases non-trivial logic can be encoded in the implicit resolution process
- Which can result in hard to decipher code and compilation errors.

---
class: center, middle, transition

Extended Example: Configuration Readers

???

- Let's put typeclasses to use
- We will now try to write a small wrapper around Typesafe config to make it a bit more useable
---

## <del>Typesafe</del> Lightbend Config

```
config.getString("clippy.name")

config.getInt("clippy.annoyanceLevel")

config.getStringList("clippy.tips")


{{content}}
```

???
- Typesafe config is rather annoying, to get something out of it, we need to call a special method that matches the type
- The number of types is limited - only the one's defined by the library authors
- And the types themselves are not always nice to work with, like the Java collections that they return

--

get[String](config, "clippy.name")

get[Int](config, "clippy.annoyanceLevel")

get[List[String]](config, "clippy.tips")


{{content}}

???

- This is the function that we want to have
- We give it the type of thing that we want to fetch, and it fetches
- Note how this is a single function for all types
- But we want more, we want to be able to extend it with our own types
- For example
--

get[Clippy](config, "clippy.annoyanceLevel")

???
- So what we want, is a "smart" function, that is open for extension by third parties
- This is perfect use case for typeclasses
---

## The Typeclass

```
trait ValueReader[A] {
  def read(config: Config, key: String): A
}


{{content}}
```

???
- This is the typeclass that we'll use
- Given some type `A`, it will give us the ability to read it from a config
- For example, here's the `Int` instance

--

implicit val intValueReader = new ValueReader[Int] {
  def read(config: Config, key: String): Int = config.getInt(key)
}


{{content}}
???
- This is just a wrapper around the original functionality
- We are adapting it to our new typeclass interface
- Similarly, we can define instances for all the built-in config getters
- Let's how we define our getter function
--

implicit val stringValueReader = new ValueReader[String] {
  def read(config: Config, key: String) = config.getString(key)
}


implicit val stringListValueReader = new ValueReader[List[String]] {
  def read(config: Config, key: Sting) =
    config.getStringList(key).asScala
}

???
- And similarly for other primitive types
- Note that here we already adapt the list to be a Scala `List`, so we already gained some adapting benefit
---

## The Getter Function
```
def get[A: ValueReader](config: Config, key: String): A =
  implicitly[ValueReader[A]].read(config, key)


{{content}}
```
???
- This can be read as follows: given a `ValueReader` for `A`, a config and a key, fetch an `A`
- The implementation is straightforward
- First summon the implicit `ValueReader` for `A`, which must be present since we have a context bound in place
- Then read the value from the config using the reader
- Alternatively, we can drop the context bound and write the function with an implicit
- Like so

--
def get[A](config: Config, key: String)
          (implicit reader: ValueReader[A]): A =
  reader.read(config, key)


???
- So what have we gained from writing it this way?
- First, this solution is extensible, anyone can write a `ValueReader` for any type they want
- Like so

---

## More Readers

```
implicit val clippyReader = new ValueReader[Clippy] {
  def read(config: Config, key: String): Clippy =
    Clippy(annoyanceLevel = config.getInt(key))
}


get[Clippy](config, "clippy.annoyanceLevel")


{{content}}
```

???
- But we can do even fancier things, we can let the compiler do the hard work for us
- As I mentioned previously, implicits are a way to communicate with the compiler
- And the compiler can derive new things for us
- Here's an example

--

implicit def optionValueReader[A: ValueReader] =
  new ValueReader[Option[A]] {
    def read(config: Config, key: String): Option[A] =
      if (config.hasPath(key)) Some(get[A](config, key))
      else None
  }


{{content}}
???
- This can be read as: given that we know how to read a value of some type `A`
- Then we can automatically derive how to read a value of `Option[A]`
- And it can be used as follows

--

get[Option[Int]](config, "clippy.annoyanceLevel")

???
- Note that we don't have to do any special construction for the `ValueReader` for `Option`
- When the compiler sees the type `Option[Int]`, it automatically finds our `opitonValueReader` and `intReader`
- And then uses them to construct the right instance for `Option[Int]`, with no new code from our side
- We can do similar things for lists or maps
- Even fancier, we can right a generic `ValueReader` that will allow the compiler to build a reader for any case class
- Though for these kinds of things we'll need either macros or `Shapeless`

---
## Pimp My Config

```
implicit class ConfigOps(config: Config) {
  def get[A: ValueReader](key: String): A = get[A](config, key)
}


{{content}}

```

???
- It may feel a bit unnatural to use our `get` function, since it's not on `config`
- To remedy this, we can use the `pimp my class pattern` to make it nicer to use

--

config\.get[Clippy]("clippy.annoyanceLevel")



???
- And now we can use it like so
- This concludes our example
- You may be pleased to know that this functionality and much more is available in the Ficus library
--

---
class: center, middle, transition

Typeclasses in the Wild

???

- In this part, we will give a brief overview of the various typeclasses the exist in the Scala ecosystem
---
## Standard Typeclasses

???
- We will start with some basic typecalsses
- The reason I'm calling them standard is because they're inspired by typeclasses in Haskell's standard library
--


```
trait Equality[A] {
  def areEqual(a: A, b: A): Boolean
}
```

???
- This can be used to customize equality checks, beyond the standard `equals` method
- For example, ScalaTest, has equality matchers that use this to override the standard equals
- Since this is extensible, as library users, you can implement use it yourself by implementing special equality checks for your tests
- E.g., for testing JSON strings, ignoring the formatting
- Note that this function is safer than the regular `equals` since it uses `A` instead of `Any` as the parameters
--

```
trait Ordering { ... }
```

???
- The `Ordering` that we already explored is defined in Scala's standard library and is used there

--

```
trait Numeric[T] {
  def fromInt(x: Int): T
  def abs(x: T): T
  ...
}
```

???
- This typeclass let's us write generic numeric code without thinking about the specific implementation
- It is present in Scala's standard library
- But it's quite slow for performance intensive code
- There's analogous code in the Spire library that should be very performant

---

## Parsing and Serialization

---
---
- Motivation: Ordering adapter interface (5 min)
- Full definition: (5 min)
  * class definition
  * instance definition
  * operator syntax
- Benefits: (10 min)
  * Extensibility
  * Compiler composition (Ord[A] => Ord[List[A]])
  * Type-driven
  * Functional style (can abstract over construction of a type) - TODO note this in some example
  * Abstract definition, many usages/code reuse (example: folding over monoids)
- Full example: add converters for typesafe config (show library that does it: https://github.com/iheartradio/ficus) (10 min)
- Examples in the wild (definitions and usage): (10 min)
  * Eq, Ord (standard library), Show
  * Numeric (standard library)
  * Parsing/serilization: JSON codecs (Play)
  * Algebraic: monoid, group (Spire)
  * Abstract: functor, applicative, monad (Scalaz, Cats)
- Extras: macro libraries for typeclass generation (shapeless, machinist) (5 min)





</textarea>
<script
	src="remark-0.13.0.min.js"
	type="text/javascript">
</script>
<script type="text/javascript">
  var slideshow = remark.create({
	highlightLanguage: 'scala',
	highlightStyle: 'magula' // default, googlecode, magula, vs
});
  //document.addEventListener('click', function (e) { slideshow.gotoNextSlide() }, false);
</script>
</body>
</html>
